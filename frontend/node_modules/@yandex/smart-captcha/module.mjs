import React, { useState, useEffect, useRef, useLayoutEffect } from 'react';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/**
 * Load script on src and run function on script load
 */
function loadScript(src, onload, onerror, onJavascriptError, immediate) {
    if (onload === void 0) { onload = null; }
    if (onerror === void 0) { onerror = null; }
    if (immediate === void 0) { immediate = true; }
    var script = document.createElement('script');
    script.src = src;
    script.onload = onload;
    script.onerror = onerror;
    script.type = 'text/javascript';
    script.crossOrigin = 'anonymous';
    if (typeof window !== 'undefined') {
        window.addEventListener('error', function handleJavascriptError(e) {
            if (e.filename.indexOf(src) === 0 && onJavascriptError) {
                onJavascriptError({
                    filename: e.filename,
                    message: e.message,
                    col: e.colno,
                    line: e.lineno,
                });
            }
        });
    }
    var addScript = function () { return document.body.appendChild(script); };
    if (immediate) {
        addScript();
    }
    else {
        window.addEventListener('load', addScript);
    }
}

/**
 * RegExps.
 * A URL must match #1 and then at least one of #2/#3.
 * Use two levels of REs to avoid REDOS.
 */
var domainRE = /^(\S+)$/;
var localhostDomainRE = /^localhost[\:?\d]*(?:[^\:?\d]\S*)?$/;
var nonLocalhostDomainRE = /^[^\s\.]+\.\S{2,}$/;
var IPv4RE = /^(https?:\/\/)?([0-9]{1,3}\.){3}[0-9]{1,3}\:\d+$/;
var IPv6RE = /^(https?:\/\/)?\[([0-9a-fA-F]{0,4}\:){7}([0-9a-fA-F]){0,4}\]\:\d+$/;
function isValidHost(str) {
    if (typeof str !== 'string') {
        return false;
    }
    var match = str.match(domainRE);
    if (!match) {
        return false;
    }
    var everythingAfterProtocol = match[0];
    if (!everythingAfterProtocol) {
        return false;
    }
    if (localhostDomainRE.test(everythingAfterProtocol) ||
        nonLocalhostDomainRE.test(everythingAfterProtocol) ||
        IPv4RE.test(everythingAfterProtocol) ||
        IPv6RE.test(everythingAfterProtocol)) {
        return true;
    }
    return false;
}

var API_LINK = function (host) {
    if (host === void 0) { host = 'smartcaptcha.yandexcloud.net'; }
    var base = /^https?/.test(host) ? host : "https://".concat(host);
    return "".concat(base, "/captcha.js?render=onload&onload=__onSmartCaptchaReady");
};

/**
 * @internal
 */
var callbacks = [];
var startLoading = new Map();
function useSmartCaptchaLoader(host, onJavascriptError) {
    var _a = __read(useState(), 2), smartCaptcha = _a[0], setSmartCaptcha = _a[1];
    useEffect(function () {
        if (host !== undefined && !isValidHost(host)) {
            throw new Error("[SmartCaptcha] ".concat(host, " host is invalid. It should be of a kind: domain.ru, localhost:3000"));
        }
        if (smartCaptcha !== undefined || (host !== undefined && !isValidHost(host))) {
            return;
        }
        if (window.__onSmartCaptchaReady === undefined) {
            window.__onSmartCaptchaReady = function () {
                callbacks.forEach(function (callback) { return callback(); });
            };
        }
        if (window.smartCaptcha) {
            setSmartCaptcha(window.smartCaptcha);
        }
        var index = callbacks.push(function () { return setSmartCaptcha(window.smartCaptcha); });
        var handleError = function () {
            onJavascriptError === null || onJavascriptError === void 0 ? void 0 : onJavascriptError({
                filename: API_LINK(host),
                message: 'Unknown error on script loading',
                col: 0,
                line: 0
            });
        };
        if (!startLoading.get(host)) {
            loadScript(API_LINK(host), null, handleError, onJavascriptError);
            startLoading.set(host, true);
        }
        return function () {
            callbacks.splice(index, 1);
        };
    }, [host, onJavascriptError, smartCaptcha]);
    return smartCaptcha;
}

function useSubscriptions(props) {
    var propsRef = useRef({});
    var widgetId = props.widgetId, smartCaptcha = props.smartCaptcha, onChallengeHidden = props.onChallengeHidden, onChallengeVisible = props.onChallengeVisible, onSuccess = props.onSuccess, onNetworkError = props.onNetworkError, onTokenExpired = props.onTokenExpired, onJavascriptError = props.onJavascriptError;
    propsRef.current = {
        onChallengeHidden: onChallengeHidden,
        onChallengeVisible: onChallengeVisible,
        onSuccess: onSuccess,
        onNetworkError: onNetworkError,
        onTokenExpired: onTokenExpired,
        onJavascriptError: onJavascriptError,
    };
    useEffect(function () {
        if (!smartCaptcha || typeof widgetId !== 'number') {
            return;
        }
        var unsubscribeFns = [
            smartCaptcha.subscribe(widgetId, 'challenge-visible', function () {
                var _a, _b;
                (_b = (_a = propsRef.current).onChallengeVisible) === null || _b === void 0 ? void 0 : _b.call(_a);
            }),
            smartCaptcha.subscribe(widgetId, 'challenge-hidden', function () {
                var _a, _b;
                (_b = (_a = propsRef.current).onChallengeHidden) === null || _b === void 0 ? void 0 : _b.call(_a);
            }),
            smartCaptcha.subscribe(widgetId, 'network-error', function () {
                var _a, _b;
                (_b = (_a = propsRef.current).onNetworkError) === null || _b === void 0 ? void 0 : _b.call(_a);
            }),
            smartCaptcha.subscribe(widgetId, 'success', function (token) {
                var _a, _b;
                (_b = (_a = propsRef.current).onSuccess) === null || _b === void 0 ? void 0 : _b.call(_a, token);
            }),
            smartCaptcha.subscribe(widgetId, 'token-expired', function () {
                var _a, _b;
                (_b = (_a = propsRef.current).onTokenExpired) === null || _b === void 0 ? void 0 : _b.call(_a);
            }),
            smartCaptcha.subscribe(widgetId, 'javascript-error', function (error) {
                var _a, _b;
                (_b = (_a = propsRef.current).onJavascriptError) === null || _b === void 0 ? void 0 : _b.call(_a, error);
            }),
        ];
        return function () { return unsubscribeFns.forEach(function (fn) { return fn === null || fn === void 0 ? void 0 : fn(); }); };
    }, [widgetId, smartCaptcha]);
}

var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;

var style = { height: 102 };
var SmartCaptcha = function (props) {
    var containerRef = useRef(null);
    var onChallengeHidden = props.onChallengeHidden, onChallengeVisible = props.onChallengeVisible, onSuccess = props.onSuccess, onNetworkError = props.onNetworkError, onTokenExpired = props.onTokenExpired, onJavascriptError = props.onJavascriptError, language = props.language, host = props.host, theme = props.theme, restProps = __rest(props, ["onChallengeHidden", "onChallengeVisible", "onSuccess", "onNetworkError", "onTokenExpired", "onJavascriptError", "language", "host", "theme"]);
    var smartCaptcha = useSmartCaptchaLoader(host, onJavascriptError);
    var _a = __read(useState(), 2), widgetId = _a[0], setWidgetId = _a[1];
    var destroyedRef = useRef({});
    useSubscriptions({
        widgetId: widgetId,
        smartCaptcha: smartCaptcha,
        onChallengeHidden: onChallengeHidden,
        onChallengeVisible: onChallengeVisible,
        onSuccess: onSuccess,
        onNetworkError: onNetworkError,
        onTokenExpired: onTokenExpired,
        onJavascriptError: onJavascriptError
    });
    useIsomorphicLayoutEffect(function () {
        if (!containerRef.current || !smartCaptcha) {
            return;
        }
        var id = smartCaptcha.render(containerRef.current, __assign(__assign({}, restProps), { hl: language, theme: theme }));
        setWidgetId(id);
        return function () {
            smartCaptcha.destroy(id);
            setWidgetId(undefined);
            // eslint-disable-next-line react-hooks/exhaustive-deps
            destroyedRef.current[id] = true;
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [smartCaptcha, language, restProps.sitekey, restProps.test, restProps.webview]);
    useEffect(function () {
        if (!widgetId || !theme) {
            return;
        }
        window.smartCaptcha.setTheme(widgetId, theme);
    }, [theme, widgetId]);
    return React.createElement("div", { ref: containerRef, className: "smart-captcha", style: style });
};

var InvisibleSmartCaptcha = function (props) {
    var containerRef = useRef(null);
    var onChallengeHidden = props.onChallengeHidden, onChallengeVisible = props.onChallengeVisible, onSuccess = props.onSuccess, onNetworkError = props.onNetworkError, onTokenExpired = props.onTokenExpired, onJavascriptError = props.onJavascriptError, language = props.language, host = props.host, theme = props.theme, restProps = __rest(props, ["onChallengeHidden", "onChallengeVisible", "onSuccess", "onNetworkError", "onTokenExpired", "onJavascriptError", "language", "host", "theme"]);
    var smartCaptcha = useSmartCaptchaLoader(host, onJavascriptError);
    var _a = __read(useState(), 2), widgetId = _a[0], setWidgetId = _a[1];
    var destroyedRef = useRef({});
    useSubscriptions({
        widgetId: widgetId,
        smartCaptcha: smartCaptcha,
        onChallengeHidden: onChallengeHidden,
        onChallengeVisible: onChallengeVisible,
        onSuccess: onSuccess,
        onNetworkError: onNetworkError,
        onTokenExpired: onTokenExpired,
        onJavascriptError: onJavascriptError
    });
    useIsomorphicLayoutEffect(function () {
        if (!containerRef.current || !smartCaptcha) {
            return;
        }
        var id = smartCaptcha.render(containerRef.current, __assign(__assign({}, restProps), { invisible: true, hl: language, theme: theme }));
        setWidgetId(id);
        return function () {
            smartCaptcha === null || smartCaptcha === void 0 ? void 0 : smartCaptcha.destroy(id);
            setWidgetId(undefined);
            // eslint-disable-next-line react-hooks/exhaustive-deps
            destroyedRef.current[id] = true;
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        smartCaptcha,
        language,
        restProps.hideShield,
        restProps.shieldPosition,
        restProps.sitekey,
        restProps.test,
        restProps.webview,
    ]);
    useEffect(function () {
        if (smartCaptcha &&
            restProps.visible &&
            typeof widgetId === 'number' &&
            !destroyedRef.current[widgetId]) {
            smartCaptcha.execute(widgetId);
        }
    }, [smartCaptcha, restProps.visible, widgetId]);
    useEffect(function () {
        if (!widgetId || !theme) {
            return;
        }
        // TODO: Удалить, когда выкатится внешка с поддержкой тем
        if (!window.smartCaptcha.setTheme) {
            return;
        }
        window.smartCaptcha.setTheme(widgetId, theme);
    }, [theme, widgetId]);
    return React.createElement("div", { ref: containerRef, className: "smart-captcha" });
};

export { InvisibleSmartCaptcha, SmartCaptcha, callbacks, useSmartCaptchaLoader };
